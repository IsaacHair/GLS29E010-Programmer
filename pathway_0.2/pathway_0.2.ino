 #define LEN 362 //********make sure to get length correct
 #define JMP 0
 #define OUT 2
 #define ADR 4
 #define BUF 6
 #define I 0
 #define R 1
uint16_t prog[LEN][4]={
    {0x0000, ADR+0, 0xffff, 0x0001}, //reset (reset to 15 since immediately incremented, so rolls over to 0)
    {0x0001, ADR+1, 0x0000, 0x0002},
    {0x0002, BUF+1, 0x0000, 0x0003},

    {0x0003, ADR+0, 0xffff, 0x0004},
    {0x0004, ADR+1, 0x0001, 0x0005},
    {0x0005, BUF+1, 0x0000, 0x0006},
    
    {0x0006, ADR+0, 0xffff, 0x0007},
    {0x0007, ADR+1, 0x0002, 0x0008},
    {0x0008, BUF+1, 0x0000, 0x0009},

    {0x0009, ADR+0, 0xffff, 0x000a},
    {0x000a, ADR+1, 0x0003, 0x000b},
    {0x000b, BUF+1, 0x0000, 0x1000},

    {0x1000, ADR+0, 0xffff, 0x1001}, //add 1
    {0x1001, ADR+1, 0x0000, 0x1002}, //0x0000 is ones digit; 0x0003 is 2^4's digit
    {0x1002, JMP+R, 0x0000, 0x1004},
    {0x1004, BUF+1, 0x0000, 0x1800},
    {0x1005, BUF+0, 0x0000, 0x1010},

    {0x1010, ADR+0, 0xffff, 0x1011},
    {0x1011, ADR+1, 0x0001, 0x1012},
    {0x1012, JMP+R, 0x0000, 0x1014},
    {0x1014, BUF+1, 0x0000, 0x1804},
    {0x1015, BUF+0, 0x0000, 0x1020},

    {0x1020, ADR+0, 0xffff, 0x1021},
    {0x1021, ADR+1, 0x0002, 0x1022},
    {0x1022, JMP+R, 0x0000, 0x1024},
    {0x1024, BUF+1, 0x0000, 0x1808},
    {0x1025, BUF+0, 0x0000, 0x1030},

    {0x1030, ADR+0, 0xffff, 0x1031},
    {0x1031, ADR+1, 0x0003, 0x1032},
    {0x1032, JMP+R, 0x0000, 0x1034},
    {0x1034, BUF+1, 0x0000, 0x2000},
    {0x1035, BUF+0, 0x0000, 0x2000},

    {0x1800, OUT+1, 0x0000, 0x1801}, //equalize clock cycles spent to add
    {0x1801, OUT+1, 0x0000, 0x1802},
    {0x1802, OUT+1, 0x0000, 0x1803},
    {0x1803, OUT+1, 0x0000, 0x1804},
    
    {0x1804, OUT+1, 0x0000, 0x1805},
    {0x1805, OUT+1, 0x0000, 0x1806},
    {0x1806, OUT+1, 0x0000, 0x1807},
    {0x1807, OUT+1, 0x0000, 0x1808},
    
    {0x1808, OUT+1, 0x0000, 0x1809},
    {0x1809, OUT+1, 0x0000, 0x180a},
    {0x180a, OUT+1, 0x0000, 0x180b},
    {0x180b, OUT+1, 0x0000, 0x2000},

    {0x2000, ADR+0, 0xffff, 0x2001}, //initialization
    {0x2001, ADR+1, 0x1800, 0x2002},
    {0x2002, BUF+0, 0x0000, 0x2010},

    {0x2010, ADR+0, 0xffff, 0x2011}, //getting values
    {0x2011, ADR+1, 0x0000, 0x2012},
    {0x2012, JMP+R, 0x0000, 0x2014},
    {0x2014, OUT+1, 0x0000, 0x3000},
    {0x2015, OUT+1, 0x0000, 0x4000},

    {0x2020, ADR+0, 0xffff, 0x2021},
    {0x2021, ADR+1, 0x0001, 0x2022},
    {0x2022, JMP+R, 0x0000, 0x2024},
    {0x2024, OUT+1, 0x0000, 0x3000},
    {0x2025, OUT+1, 0x0000, 0x4000},

    {0x2030, ADR+0, 0xffff, 0x2031},
    {0x2031, ADR+1, 0x0002, 0x2032},
    {0x2032, JMP+R, 0x0000, 0x2034},
    {0x2034, OUT+1, 0x0000, 0x3000},
    {0x2035, OUT+1, 0x0000, 0x4000},

    {0x2040, ADR+0, 0xffff, 0x2041},
    {0x2041, ADR+1, 0x0003, 0x2042},
    {0x2042, JMP+R, 0x0000, 0x2044},
    {0x2044, OUT+1, 0x0000, 0x3000},
    {0x2045, OUT+1, 0x0000, 0x4000},


    {0x3000, ADR+0, 0xffff, 0x3001}, //if the value is a zero - bit 0
    {0x3001, ADR+1, 0x1800, 0x3002},
    {0x3002, JMP+R, 0x0000, 0x3004},
    {0x3004, OUT+1, 0x0000, 0x3006}, //this is end of path
    {0x3005, OUT+1, 0x0000, 0x300d}, //this is not end of path

    {0x3006, BUF+1, 0x0000, 0x3007}, //set this as not being end
    {0x3007, ADR+0, 0xfff1, 0x3008},
    {0x3008, ADR+1, 0x1810, 0x3009},
    {0x3009, BUF+0, 0x0000, 0x300a}, //set what will be the next address (by changing the 1 bit that is being worked on right now) as the end
    {0x300a, ADR+0, 0xfff1, 0x300b},
    {0x300b, ADR+1, 0x1000, 0x300c},
    {0x300c, BUF+0, 0x0000, 0x2020}, //write value so the program knows what to make the next address

    {0x300d, ADR+0, 0xfff0, 0x300e},
    {0x300e, ADR+1, 0x1000, 0x300f},
    {0x300f, JMP+R, 0x0000, 0x3010}, //seeing where to lead path as end
    {0x3010, ADR+0, 0x0001, 0x3a00},
    {0x3011, ADR+1, 0x0001, 0x3a00},


    {0x3a00, ADR+0, 0xfff0, 0x3a01}, //bit 1
    {0x3a01, ADR+1, 0x1810, 0x3a02},
    {0x3a02, JMP+R, 0x0000, 0x3a04},
    {0x3a04, OUT+1, 0x0000, 0x3a06}, //this is end of path
    {0x3a05, OUT+1, 0x0000, 0x3a0d}, //this is not end of path

    {0x3a06, BUF+1, 0x0000, 0x3a07}, //set this as not being end
    {0x3a07, ADR+0, 0xfff2, 0x3a08},
    {0x3a08, ADR+1, 0x1820, 0x3a09},
    {0x3a09, BUF+0, 0x0000, 0x3a0a}, //set what will be the next address (by changing the 1 bit that is being worked on right now) as the end
    {0x3a0a, ADR+0, 0xfff2, 0x3a0b},
    {0x3a0b, ADR+1, 0x1010, 0x3a0c},
    {0x3a0c, BUF+0, 0x0000, 0x2030}, //write value so the program knows what to make the next address

    {0x3a0d, ADR+0, 0xfff0, 0x3a0e},
    {0x3a0e, ADR+1, 0x1010, 0x3a0f},
    {0x3a0f, JMP+R, 0x0000, 0x3a10}, //seeing where to lead path as end
    {0x3a10, ADR+0, 0x0002, 0x3200},
    {0x3a11, ADR+1, 0x0002, 0x3200},


    {0x3200, ADR+0, 0xfff0, 0x3201}, //bit 2
    {0x3201, ADR+1, 0x1820, 0x3202},
    {0x3202, JMP+R, 0x0000, 0x3204},
    {0x3204, OUT+1, 0x0000, 0x3206}, //this is end of path
    {0x3205, OUT+1, 0x0000, 0x320d}, //this is not end of path

    {0x3206, BUF+1, 0x0000, 0x3207}, //set this as not being end
    {0x3207, ADR+0, 0xfff4, 0x3208},
    {0x3208, ADR+1, 0x1830, 0x3209},
    {0x3209, BUF+0, 0x0000, 0x320a}, //set what will be the next address (by changing the 1 bit that is being worked on right now) as the end
    {0x320a, ADR+0, 0xfff4, 0x320b},
    {0x320b, ADR+1, 0x1020, 0x320c},
    {0x320c, BUF+0, 0x0000, 0x2040}, //write value so the program knows what to make the next address

    {0x320d, ADR+0, 0xfff0, 0x320e},
    {0x320e, ADR+1, 0x1020, 0x320f},
    {0x320f, JMP+R, 0x0000, 0x3210}, //seeing where to lead path as end
    {0x3210, ADR+0, 0x0004, 0x3c00},
    {0x3211, ADR+1, 0x0004, 0x3c00},


    {0x3c00, ADR+0, 0xfff0, 0x3c01}, //add on last bit and clear rest of number
    {0x3c01, ADR+1, 0x1030, 0x5000},


    {0x4000, ADR+0, 0xffff, 0x4001}, //if the value is a one - bit 0
    {0x4001, ADR+1, 0x1800, 0x4002},
    {0x4002, JMP+R, 0x0000, 0x4004},
    {0x4004, OUT+1, 0x0000, 0x4006}, //this is the end of the path
    {0x4005, OUT+1, 0x0000, 0x400d}, //this is not the end of the path

    {0x4006, BUF+1, 0x0000, 0x4007}, //set this as not being the end
    {0x4007, ADR+0, 0xfff1, 0x4008},
    {0x4008, ADR+1, 0x1811, 0x4009},
    {0x4009, BUF+0, 0x0000, 0x400a}, //set what will be the next address (by changing the 1 bit that is worked on right now) as the end
    {0x400a, ADR+0, 0xfff1, 0x400b},
    {0x400b, ADR+1, 0x1000, 0x400c},
    {0x400c, BUF+1, 0x0000, 0x2020}, //write value so program knows where to make next address

    {0x400d, ADR+0, 0xfff0, 0x400e},
    {0x400e, ADR+1, 0x1000, 0x400f},
    {0x400f, JMP+R, 0x0000, 0x4010}, //seeing where to lead path as end
    {0x4010, ADR+0, 0x0001, 0x4a00},
    {0x4011, ADR+1, 0x0001, 0x4a00},


    {0x4a00, ADR+0, 0xfff0, 0x4a01}, //bit 1
    {0x4a01, ADR+1, 0x1810, 0x4a02},
    {0x4a02, JMP+R, 0x0000, 0x4a04},
    {0x4a04, OUT+1, 0x0000, 0x4a06}, //this is the end of the path
    {0x4a05, OUT+1, 0x0000, 0x4a0d}, //this is not the end of the path

    {0x4a06, BUF+1, 0x0000, 0x4a07}, //set this as not being the end
    {0x4a07, ADR+0, 0xfff2, 0x4a08},
    {0x4a08, ADR+1, 0x1822, 0x4a09},
    {0x4a09, BUF+0, 0x0000, 0x4a0a}, //set what will be the next address (by changing the 1 bit that is worked on right now) as the end
    {0x4a0a, ADR+0, 0xfff2, 0x4a0b},
    {0x4a0b, ADR+1, 0x1010, 0x4a0c},
    {0x4a0c, BUF+1, 0x0000, 0x2030}, //write value so program knows where to make next address

    {0x4a0d, ADR+0, 0xfff0, 0x4a0e},
    {0x4a0e, ADR+1, 0x1010, 0x4a0f},
    {0x4a0f, JMP+R, 0x0000, 0x4a10}, //seeing where to lead path as end
    {0x4a10, ADR+0, 0x0002, 0x4200},
    {0x4a11, ADR+1, 0x0002, 0x4200},


    {0x4200, ADR+0, 0xfff0, 0x4201}, //bit 2
    {0x4201, ADR+1, 0x1820, 0x4202},
    {0x4202, JMP+R, 0x0000, 0x4204},
    {0x4204, OUT+1, 0x0000, 0x4206}, //this is the end of the path
    {0x4205, OUT+1, 0x0000, 0x420d}, //this is not the end of the path

    {0x4206, BUF+1, 0x0000, 0x4207}, //set this as not being the end
    {0x4207, ADR+0, 0xfff4, 0x4208},
    {0x4208, ADR+1, 0x1834, 0x4209},
    {0x4209, BUF+0, 0x0000, 0x420a}, //set what will be the next address (by changing the 1 bit that is worked on right now) as the end
    {0x420a, ADR+0, 0xfff4, 0x420b},
    {0x420b, ADR+1, 0x1020, 0x420c},
    {0x420c, BUF+1, 0x0000, 0x2040}, //write value so program knows where to make next address
    
    {0x420d, ADR+0, 0xfff0, 0x420e},
    {0x420e, ADR+1, 0x1020, 0x420f},
    {0x420f, JMP+R, 0x0000, 0x4210}, //seeing where to lead path as end
    {0x4210, ADR+0, 0x0004, 0x4c00},
    {0x4211, ADR+1, 0x0004, 0x4c00},


    {0x4c00, ADR+0, 0xfff0, 0x4c01}, //set address properly and write last bit of address
    {0x4c01, ADR+1, 0x1038, 0x5000},


    {0x5000, JMP+I, 0x0001, 0x5002},
    {0x5002, OUT+1, 0x0000, 0x5004}, //reset number if input held low
    {0x5003, OUT+1, 0x0000, 0x5005},

    {0x5004, BUF+0, 0x0000, 0x5a00}, //divert to printing 0 (continues to next digit afterward)

    {0x5005, JMP+R, 0x0000, 0x5006}, //test value
    {0x5006, BUF+1, 0xffff, 0x5200}, //flip to one
    {0x5007, BUF+0, 0xffff, 0x5a00}, //flip to zero


    {0x5a00, ADR+0, 0xffff, 0x5a01}, //printing 0
    {0x5a01, ADR+1, 0x0003, 0x5a02}, //3rd digit
    {0x5a02, JMP+R, 0x0000, 0x5a04},
    {0x5a04, ADR+0, 0xffff, 0x5a10},
    {0x5a05, ADR+0, 0xffff, 0x5a20},


    {0x5a10, ADR+0, 0xffff, 0x5a11}, //2nd digit
    {0x5a11, ADR+1, 0x0002, 0x5a12},
    {0x5a12, JMP+R, 0x0000, 0x5a14},
    {0x5a14, ADR+0, 0xffff, 0x5a30},
    {0x5a15, ADR+0, 0xffff, 0x5a40},

    {0x5a20, ADR+0, 0xffff, 0x5a21},
    {0x5a21, ADR+1, 0x0002, 0x5a22},
    {0x5a22, JMP+R, 0x0000, 0x5a24},
    {0x5a24, ADR+0, 0xffff, 0x5a50},
    {0x5a25, ADR+0, 0xffff, 0x5a60},


    {0x5a30, ADR+0, 0xffff, 0x5a31}, //1st digit
    {0x5a31, ADR+1, 0x0001, 0x5a32},
    {0x5a32, JMP+R, 0x0000, 0x5a34},
    {0x5a34, ADR+0, 0xffff, 0x5a70},
    {0x5a35, ADR+0, 0xffff, 0x5a80},

    {0x5a40, ADR+0, 0xffff, 0x5a41},
    {0x5a41, ADR+1, 0x0001, 0x5a42},
    {0x5a42, JMP+R, 0x0000, 0x5a44},
    {0x5a44, ADR+0, 0xffff, 0x5a90},
    {0x5a45, ADR+0, 0xffff, 0x5aa0},

    {0x5a50, ADR+0, 0xffff, 0x5a51},
    {0x5a51, ADR+1, 0x0001, 0x5a52},
    {0x5a52, JMP+R, 0x0000, 0x5a54},
    {0x5a54, ADR+0, 0xffff, 0x5ab0},
    {0x5a55, ADR+0, 0xffff, 0x5ac0},

    {0x5a60, ADR+0, 0xffff, 0x5a61},
    {0x5a61, ADR+1, 0x0001, 0x5a62},
    {0x5a62, JMP+R, 0x0000, 0x5a64},
    {0x5a64, ADR+0, 0xffff, 0x5ad0},
    {0x5a65, ADR+0, 0xffff, 0x5ae0},


    {0x5a70, ADR+0, 0xffff, 0x5a71}, //0th digit
    {0x5a71, ADR+1, 0x0000, 0x5a72},
    {0x5a72, JMP+R, 0x0000, 0x5a74},
    {0x5a74, ADR+0, 0xffff, 0x5400},
    {0x5a75, ADR+0, 0xffff, 0x5401},

    {0x5a80, ADR+0, 0xffff, 0x5a81},
    {0x5a81, ADR+1, 0x0000, 0x5a82},
    {0x5a82, JMP+R, 0x0000, 0x5a84},
    {0x5a84, ADR+0, 0xffff, 0x5402},
    {0x5a85, ADR+0, 0xffff, 0x5403},

    {0x5a90, ADR+0, 0xffff, 0x5a91},
    {0x5a91, ADR+1, 0x0000, 0x5a92},
    {0x5a92, JMP+R, 0x0000, 0x5a94},
    {0x5a94, ADR+0, 0xffff, 0x5404},
    {0x5a95, ADR+0, 0xffff, 0x5405},
    
    {0x5aa0, ADR+0, 0xffff, 0x5aa1},
    {0x5aa1, ADR+1, 0x0000, 0x5aa2},
    {0x5aa2, JMP+R, 0x0000, 0x5aa4},
    {0x5aa4, ADR+0, 0xffff, 0x5406},
    {0x5aa5, ADR+0, 0xffff, 0x5407},

    {0x5ab0, ADR+0, 0xffff, 0x5ab1}, //still 0th digit
    {0x5ab1, ADR+1, 0x0000, 0x5ab2},
    {0x5ab2, JMP+R, 0x0000, 0x5ab4},
    {0x5ab4, ADR+0, 0xffff, 0x5408},
    {0x5ab5, ADR+0, 0xffff, 0x5409},

    {0x5ac0, ADR+0, 0xffff, 0x5ac1},
    {0x5ac1, ADR+1, 0x0000, 0x5ac2},
    {0x5ac2, JMP+R, 0x0000, 0x5ac4},
    {0x5ac4, ADR+0, 0xffff, 0x540a},
    {0x5ac5, ADR+0, 0xffff, 0x540b},

    {0x5ad0, ADR+0, 0xffff, 0x5ad1},
    {0x5ad1, ADR+1, 0x0000, 0x5ad2},
    {0x5ad2, JMP+R, 0x0000, 0x5ad4},
    {0x5ad4, ADR+0, 0xffff, 0x540c},
    {0x5ad5, ADR+0, 0xffff, 0x540d},

    {0x5ae0, ADR+0, 0xffff, 0x5ae1},
    {0x5ae1, ADR+1, 0x0000, 0x5ae2},
    {0x5ae2, JMP+R, 0x0000, 0x5ae4},
    {0x5ae4, ADR+0, 0xffff  , 0x540e},
    {0x5ae5, ADR+0, 0xffff, 0x540f},


    {0x5400, OUT+0, 0x0001, 0x1000}, //actually print it
    {0x5401, OUT+0, 0x0002, 0x1000},
    {0x5402, OUT+0, 0x0004, 0x1000},
    {0x5403, OUT+0, 0x0008, 0x1000},
    {0x5404, OUT+0, 0x0010, 0x1000},
    {0x5405, OUT+0, 0x0020, 0x1000},
    {0x5406, OUT+0, 0x0040, 0x1000},
    {0x5407, OUT+0, 0x0080, 0x1000},

    {0x5408, OUT+0, 0x0100, 0x1000},
    {0x5409, OUT+0, 0x0200, 0x1000},
    {0x540a, OUT+0, 0x0400, 0x1000},
    {0x540b, OUT+0, 0x0800, 0x1000},
    {0x540c, OUT+0, 0x1000, 0x1000},
    {0x540d, OUT+0, 0x2000, 0x1000},
    {0x540e, OUT+0, 0x4000, 0x1000},
    {0x540f, OUT+0, 0x8000, 0x1000},



    {0x5200, ADR+0, 0xffff, 0x5201}, //printing 1
    {0x5201, ADR+1, 0x0003, 0x5202}, //3rd digit
    {0x5202, JMP+R, 0x0000, 0x5204},
    {0x5204, ADR+0, 0xffff, 0x5210},
    {0x5205, ADR+0, 0xffff, 0x5220},


    {0x5210, ADR+0, 0xffff, 0x5211}, //2nd digit
    {0x5211, ADR+1, 0x0002, 0x5212},
    {0x5212, JMP+R, 0x0000, 0x5214},
    {0x5214, ADR+0, 0xffff, 0x5230},
    {0x5215, ADR+0, 0xffff, 0x5240},

    {0x5220, ADR+0, 0xffff, 0x5221},
    {0x5221, ADR+1, 0x0002, 0x5222},
    {0x5222, JMP+R, 0x0000, 0x5224},
    {0x5224, ADR+0, 0xffff, 0x5250},
    {0x5225, ADR+0, 0xffff, 0x5260},


    {0x5230, ADR+0, 0xffff, 0x5231}, //1st digit
    {0x5231, ADR+1, 0x0001, 0x5232},
    {0x5232, JMP+R, 0x0000, 0x5234},
    {0x5234, ADR+0, 0xffff, 0x5270},
    {0x5235, ADR+0, 0xffff, 0x5280},

    {0x5240, ADR+0, 0xffff, 0x5241},
    {0x5241, ADR+1, 0x0001, 0x5242},
    {0x5242, JMP+R, 0x0000, 0x5244},
    {0x5244, ADR+0, 0xffff, 0x5290},
    {0x5245, ADR+0, 0xffff, 0x52a0},
    
    {0x5250, ADR+0, 0xffff, 0x5251},
    {0x5251, ADR+1, 0x0001, 0x5252},
    {0x5252, JMP+R, 0x0000, 0x5254},
    {0x5254, ADR+0, 0xffff, 0x52b0},
    {0x5255, ADR+0, 0xffff, 0x52c0},

    {0x5260, ADR+0, 0xffff, 0x5261},
    {0x5261, ADR+1, 0x0001, 0x5262},
    {0x5262, JMP+R, 0x0000, 0x5264},
    {0x5264, ADR+0, 0xffff, 0x52d0},
    {0x5265, ADR+0, 0xffff, 0x52e0},


    {0x5270, ADR+0, 0xffff, 0x5271}, //0th digit
    {0x5271, ADR+1, 0x0000, 0x5272},
    {0x5272, JMP+R, 0x0000, 0x5274},
    {0x5274, ADR+0, 0xffff, 0x5800},
    {0x5275, ADR+0, 0xffff, 0x5801},

    {0x5280, ADR+0, 0xffff, 0x5281},
    {0x5281, ADR+1, 0x0000, 0x5282},
    {0x5282, JMP+R, 0x0000, 0x5284},
    {0x5284, ADR+0, 0xffff, 0x5802},
    {0x5285, ADR+0, 0xffff, 0x5803},

    {0x5290, ADR+0, 0xffff, 0x5291},
    {0x5291, ADR+1, 0x0000, 0x5292},
    {0x5292, JMP+R, 0x0000, 0x5294},
    {0x5294, ADR+0, 0xffff, 0x5804},
    {0x5295, ADR+0, 0xffff, 0x5805},
   
    {0x52a0, ADR+0, 0xffff, 0x52a1},
    {0x52a1, ADR+1, 0x0000, 0x52a2},
    {0x52a2, JMP+R, 0x0000, 0x52a4},
    {0x52a4, ADR+0, 0xffff, 0x5806},
    {0x52a5, ADR+0, 0xffff, 0x5807},

    {0x52b0, ADR+0, 0xffff, 0x52b1}, //still 0th digit
    {0x52b1, ADR+1, 0x0000, 0x52b2},
    {0x52b2, JMP+R, 0x0000, 0x52b4},
    {0x52b4, ADR+0, 0xffff, 0x5808},
    {0x52b5, ADR+0, 0xffff, 0x5809},
    
    {0x52c0, ADR+0, 0xffff, 0x52c1},
    {0x52c1, ADR+1, 0x0000, 0x52c2},
    {0x52c2, JMP+R, 0x0000, 0x52c4},
    {0x52c4, ADR+0, 0xffff, 0x580a},
    {0x52c5, ADR+0, 0xffff, 0x580b},

    {0x52d0, ADR+0, 0xffff, 0x52d1},
    {0x52d1, ADR+1, 0x0000, 0x52d2},
    {0x52d2, JMP+R, 0x0000, 0x52d4},
    {0x52d4, ADR+0, 0xffff, 0x580c},
    {0x52d5, ADR+0, 0xffff, 0x580d},

    {0x52e0, ADR+0, 0xffff, 0x52e1},
    {0x52e1, ADR+1, 0x0000, 0x52e2},
    {0x52e2, JMP+R, 0x0000, 0x52e4},
    {0x52e4, ADR+0, 0xffff, 0x580e},
    {0x52e5, ADR+0, 0xffff, 0x580f},


    {0x5800, OUT+1, 0x0001, 0x0000}, //actually print it
    {0x5801, OUT+1, 0x0002, 0x0000},
    {0x5802, OUT+1, 0x0004, 0x0000},
    {0x5803, OUT+1, 0x0008, 0x0000},
    {0x5804, OUT+1, 0x0010, 0x0000},
    {0x5805, OUT+1, 0x0020, 0x0000},
    {0x5806, OUT+1, 0x0040, 0x0000},
    {0x5807, OUT+1, 0x0080, 0x0000},

    {0x5808, OUT+1, 0x0100, 0x0000},
    {0x5809, OUT+1, 0x0200, 0x0000},
    {0x580a, OUT+1, 0x0400, 0x0000},
    {0x580b, OUT+1, 0x0800, 0x0000},
    {0x580c, OUT+1, 0x1000, 0x0000},
    {0x580d, OUT+1, 0x2000, 0x0000},
    {0x580e, OUT+1, 0x4000, 0x0000},
    {0x580f, OUT+1, 0x8000, 0x0000},
    };


void setup() {
  int i, j;

  for (i = 0; i < 54; i++)
    pinMode(i, OUTPUT);

  digitalWrite(52, HIGH);
  digitalWrite(53, HIGH);
  
  for (i = 0; i < 160; i++, delay(25)) //4 second delay to reset
    if (i%2)
      digitalWrite(19, HIGH);
    else
      digitalWrite(19, LOW);

  for (i = 0; i < LEN; i++) { //write instructions
    for (j = 0; j < 52; j++) //resetting pins
      digitalWrite(j, LOW);

    for (j = 0; j < 16; j++) //current address
      if ((int) (prog[i][0]/pow(2, 15-j)) % 2)
        digitalWrite(51-j*2, HIGH);

    for (j = 35; j < 51; j++) //next address
      if ((int) (prog[i][3]/pow(2, 50-j)) % 2)
        digitalWrite(120-j*2, HIGH);

    for (j = 16; j < 19; j++) //operation code
      if ((int) (prog[i][1]/pow(2, 18-j)) % 2)
        digitalWrite(j, HIGH);

    for (j = 19; j < 35; j++) //operand
      if ((int) (prog[i][2]/pow(2, 34-j)) % 2)
        digitalWrite(j-19, HIGH);

    delay(1);
    digitalWrite(52, LOW);
    delay(1);
    digitalWrite(52, HIGH);
    delay(1);
  }

  digitalWrite(52, HIGH);
  digitalWrite(53, LOW);

  for (i = 0; i < 52; i++)
    pinMode(i, INPUT);
}

void loop() {

}
